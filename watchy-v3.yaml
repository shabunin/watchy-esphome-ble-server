substitutions:
  <<: !include pins-v3.yaml

packages:
  ble: !include ble.yaml
  alarms: !include alarms.yaml
  notifications: !include notifications.yaml
  music: !include music.yaml

# to be able to parse json in lambdas
json:

globals:
  - id: global_mode
    type: int
    initial_value: '0' 
  - id: global_page
    type: int
    initial_value: '0' 

esphome:
  name: watchy_minimal
  project:
    name: bobalus.watchy-ble
    version: "1.0"
  includes:
    - defs.h
  on_boot:
    then:
      - delay: 1ms
      # - pcf8563.read_time: # Only for Watchy v2
      - component.update: battery
      - component.update: epaper
      - lambda: |-
          // TODO: write me here

esp32:  
  board: esp32-s3-devkitc-1
  flash_size: 8MB
  # https://raw.githubusercontent.com/espressif/arduino-esp32/master/tools/partitions/default_8MB.csv
  partitions: default_8MB.csv
  variant: esp32s3
  framework:
    type: esp-idf

deep_sleep:
  # https://esphome.io/components/deep_sleep.html
  wakeup_pin_mode: INVERT_WAKEUP
  wakeup_pin:
    number: $BUTTON_LEFT_TOP_PIN
    inverted: $BUTTON_PIN_INVERTED
    allow_other_uses: true

spi:
  clk_pin: ${SPI_SCK_PIN}
  mosi_pin: ${SPI_MOSI_PIN}
  miso_pin: ${SPI_MISO_PIN}

i2c:
  sda: ${I2C_SDA_PIN}
  scl: ${I2C_SCL_PIN}
  scan: false

debug:
  update_interval: 5s

text_sensor:
  - platform: debug
    device:
      name: "Device Info"
    reset_reason:
      name: "Reset Reason"

sensor:
  # https://esphome.io/components/sensor/index.html
  - platform: debug
    free:
      name: "Heap Free"
  # https://esphome.io/components/sensor/adc.html
  - platform: adc
    id: battery
    attenuation: auto
    pin: $BATTERY_ADC_PIN
    update_interval: never
    filters:
      - multiply: $BATTERY_VOLTAGE_DIVIDER

switch:
  # https://esphome.io/components/switch/index.html
  # https://esphome.io/components/switch/gpio.html
  # https://esphome.io/components/switch/template.html

  - platform: gpio
    id: buzzer
    pin: $VIB_MOTOR_PIN

binary_sensor:
  # https://esphome.io/components/binary_sensor
  # https://esphome.io/components/binary_sensor/gpio

  ## Upper Left ##
  - id: button_left_top_short
    pin:
      number: $BUTTON_LEFT_TOP_PIN
      allow_other_uses: true
      inverted: $BUTTON_PIN_INVERTED
    platform: gpio
    on_click:
      min_length: 0ms
      max_length: 2s
      then:
        - lambda: |-
            id(buzzer).turn_on();
            
  - id: button_left_top_long
    pin:
      number: $BUTTON_LEFT_TOP_PIN
      allow_other_uses: true
      inverted: $BUTTON_PIN_INVERTED
    platform: gpio
    filters:
      delayed_on: 3s
    on_press:
      - lambda: |-
          id(buzzer).turn_off();
          
  ## Lower Left ##
  - id: button_left_bottom_short
    pin:
      number: $BUTTON_LEFT_BOTTOM_PIN
      allow_other_uses: true
      inverted: $BUTTON_PIN_INVERTED
    platform: gpio
    on_click:
      min_length: 0ms
      max_length: 2s
      then:
        - lambda: |-
            id(buzzer).turn_on();

  - id: button_left_bottom_long
    pin:
      number: $BUTTON_LEFT_BOTTOM_PIN
      allow_other_uses: true
      inverted: $BUTTON_PIN_INVERTED
    platform: gpio
    filters:
      delayed_on: 3s
    on_press:
      - lambda: |-
          id(buzzer).turn_off();

  ## Upper Right ##

  - id: button_right_top_short
    pin:
      number: $BUTTON_RIGHT_TOP_PIN
      allow_other_uses: true
      inverted: $BUTTON_PIN_INVERTED
    platform: gpio
    on_click:
      min_length: 0ms
      max_length: 2s
      then:
        - lambda: |-
            id(buzzer).turn_on();

  - id: button_right_top_long
    pin:
      number: $BUTTON_RIGHT_TOP_PIN
      allow_other_uses: true
      inverted: $BUTTON_PIN_INVERTED
    platform: gpio
    filters:
      delayed_on: 3s
    on_press:
      - lambda: |-
          id(buzzer).turn_off();

  ## Lower Right ##

  - id: button_right_bottom_short
    pin:
      number: $BUTTON_RIGHT_BOTTOM_PIN
      allow_other_uses: true
      inverted: $BUTTON_PIN_INVERTED
    platform: gpio
    on_click:
      min_length: 0ms
      max_length: 2s
      then:
        - lambda: |-
            id(buzzer).turn_on();

  - id: button_right_bottom_long
    pin:
      number: $BUTTON_RIGHT_BOTTOM_PIN
      allow_other_uses: true
      inverted: $BUTTON_PIN_INVERTED
    platform: gpio
    filters:
      delayed_on: 3s
    on_press:
      - lambda: |-
          id(buzzer).turn_on();
          id(epaper).update();
          id(buzzer).turn_off();
          
  ## Charging ##
  - id: is_charging
    pin:
      # number: $CHRG_STATUS_PIN # Does not seem to work
      number: $USB_DET_PIN
      # inverted: true
    platform: gpio
    ## This pin seems to be unstable and can flip randomly, causing too many epaper updates:
    # on_state:
    #   component.update: epaper

logger:
  level: debug

font:
  - id: ubuntumono18
    file: "gfonts://Ubuntu+Mono"
    size: 18
  - id: ubuntumono20
    file: "gfonts://Ubuntu+Mono"
    size: 20
  - id: ubuntumono22
    file: "gfonts://Ubuntu+Mono"
    size: 22
  - id: ubuntumono28
    file: "gfonts://Ubuntu+Mono"
    size: 28
  - id: ubuntumono32
    file: "gfonts://Ubuntu+Mono"
    size: 32

display:
  # Configuration for the display
  # https://esphome.io/components/display/
  # https://esphome.io/components/display/waveshare_epaper.html
  # https://www.good-display.com/product/206.html
  # https://www.e-paper-display.com/products_detail/productId=455.html
  - id: epaper
    platform: waveshare_epaper
    model: 1.54inv2
    cs_pin: $DISPLAY_CS_PIN
    dc_pin: $DISPLAY_DC_PIN
    reset_pin: $DISPLAY_RES_PIN
    busy_pin: $DISPLAY_BUSY_PIN
    update_interval: never
    # Problem: full_update_every does not work as expected because esphome code will do a full update on every boot up.
    # Solution: Edited `waveshare_epaper.h` and initialise to 1 instead of 0: `uint32_t at_update_{1};`
    # See: `external_components` near the bottom.
    full_update_every: 1000
    # Duration for the display reset operation. Defaults to 200ms. Setting this value to 2ms may resolve issues with newer e-Paper Driver modules (e.g. Rev 2.1).
    reset_duration: 2ms # ?????
    lambda: |-
      auto w = it.get_width();
      auto h = it.get_height();
      const auto BLACK = Color::WHITE;
      const auto WHITE = Color::BLACK;

      struct tm timeinfo;
      time_t now;
      time(&now);

      it.filled_rectangle(0, 0, w, h, BLACK); // clear entire background
      it.filled_rectangle(0, 0, w, h, WHITE); // clear entire background
            
      it.printf(w/2, h-30,
              id(ubuntumono22),
              TextAlign::TOP_CENTER,
              "bat: %.02fV", id(battery).state);

        localtime_r(&now, &timeinfo);

        ESP_LOGI("TIME", "Local time: %02d:%02d:%02d", timeinfo.tm_hour, timeinfo.tm_min, timeinfo.tm_sec);

        it.printf(it.get_width() / 2, 30,
                  id(ubuntumono32), TextAlign::CENTER,
                   "%02d:%02d", timeinfo.tm_hour, timeinfo.tm_min);

        it.printf(it.get_width() / 2, 80,
                  id(ubuntumono32), TextAlign::CENTER,
                  "%04d-%02d-%02d",
                  timeinfo.tm_year + 1900,
                  timeinfo.tm_mon + 1,
                  timeinfo.tm_mday);

external_components:
  # https://esphome.io/components/external_components.html
  # This project used a slightly modified module forked from the main ESPHome project.
  # The minor customisations for Watchy are:
  #  Prevent a full ePaper refresh on ESP32 boot which is not the desired behaviour for a low-power watch.
  #   https://github.com/multipolygon/esphome/commit/6407a74ff9855d515cb16fef67f90c748f9800ea
  #  Add a pubic `do_full_update()` method to trigger the full-refresh only at certain times of day - a full update clears away ghost pixels.
  #   https://github.com/multipolygon/esphome/commit/ecf116058cc4b20007126f9099f4b07f4d46b9dd
  - components: [waveshare_epaper]
    source:
      # type: local
      # path: ../esphome/esphome/components
      type: git
      url: https://github.com/multipolygon/esphome
      ref: dev

